
reset();

import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)

load("list_sorting.sage");
load("ISD.sage");


def log2(x):
    return log(x*1.)/log(2.);
               
############################################

#Compute support of matrix (i.e., positions of non null columns)
def matrix_support(B,k,n):

    #Check support of matrix
    supp = [];
    for i in range(n):
        b_i = B[:,i];
        num_zeros = b_i.list().count(0);
        if num_zeros < k:
            supp.append(i);

    return supp;


##################################################################

#Prepare lists with entries picked from all_entries; the number of considered elements is specified by num_dispositions
def prepare_lists(Zq, input_matrix, num_dispositions, sub_Htr, target_E, sign_val):

    list_values = [];
    list_sums = [];
    
    n = input_matrix.ncols();
    ell = input_matrix.nrows();

    #To generate list elements, we first generate all combinations
    pos_list = Combinations(range(n),num_dispositions);
    
    for pos in pos_list:

        all_dispositions = Permutations(pos);
        for Y_pos in all_dispositions:

            #Assign to Y the columns of input_matrix which are indexed by Y_pos
            Y = matrix(Zq,ell, num_dispositions);
            for i in range(num_dispositions):
                Y[:,i] = input_matrix[:,Y_pos[i]];

          #  print(target_E)
          #  print("--")
          #  print(Y)
          #  print("--")
          #  print(sub_Htr)
            sub_syndrome_of_Y = target_E + sign_val*Y*sub_Htr;
            list_sums.append(sub_syndrome_of_Y);
            list_values.append(Y);

    return list_values, list_sums;

################################################

#Merge two lists, using the indexes of collisions provided in list_indexes
def merge_lists(Zq, list_a, list_b, list_indexes, num_distinct,ell):
    
    
    #Construct merged lists and remove duplicates
    list_values = [];
    list_sums = [];
    
    for pos in list_indexes:
        i_a = pos[0];
        i_b = pos[1];
        C_a = list_a[i_a];
        C_b = list_b[i_b];
        
        #Checking for repeated columns (with schoolbook algorithm, not efficient)
        flag_distinct = 1;
        for i in range(C_a.ncols()):
            for j in range(C_b.ncols()):

                num_same = 0;
                for v in range(ell):
                    if (C_a[v,i] == C_b[v,j]):
                        num_same+= 1;

                if num_same == ell:
                    flag_distinct = 0;
        
        if flag_distinct:
            new_C = block_matrix(Zq, 1,2, [C_a, C_b]);
            list_values.append(new_C);
    
    return list_values;


##################################################

##Generate a random PKP instance over Zq, with ell = 1. The output public vector has all distinct elements
def random_PKP_instance_mono_dimensional(q,n,m):
    
    Zq = Integers(q);
    
    #Generate random matrix A with m rows, n columns and full rank
    rank_A = 0;
    while rank_A < m:
        A = random_matrix(Zq,m,n);
        rank_A = rank(A);
        
    
    #Find kernel element with all distinct elements
    #Use A as parity-check matrix of code C, compute generator for C and find codeword with distinct entries
    #Exploit information set to speed-up the search
    
    k = n-m;
    
    Zq_list = Zq.list();
    
    C_dual = codes.LinearCode(A); #code generated by A
    G_A = C_dual.parity_check_matrix(); #generator matrix for code whose parity-check is A
    
    #Check if there G_A can be put into systematic form, otherwise apply random permutation
    while rank(G_A[:,0:k])< k:
        P = Permutations(range(1,n+1)).random_element().to_matrix();
        A = A*P;
        G_A = G_A*P;
    
    
    G_A_sys = G_A[:,0:k]^-1*G_A;
    
    flag_c = 0; #flag_c = 1 when codeword with distinct entries is found
    while flag_c == 0:
        
        #Generate u with k distinct entries
        P = Permutations(range(n)).random_element();
        info_seq = matrix(Zq,1,k);
        for i in range(k):
            info_seq[0,i] = Zq_list[P[i]];
        
        #Compute codeword corresponding to u
        c = info_seq*G_A_sys;
        
        #Check if u has all distinct entries
        unique_values = uniq(c.list());
        if len(unique_values) == n:
            flag_c = 1;
            
    ##Apply random permutations
    secret_P = Permutations(range(n)).random_element();
    c_perm = matrix(Zq,1,n);
    for i in range(n):
        c_perm[0,i] = c[0,secret_P[i]];
    
    
    return A, c, c_perm, secret_P;
    
    
#################################################


##Generate a random PKP instance over Zq, with ell > 1
def random_PKP_instance_multi_dimensional(q,n,m,ell):

    Zq = Integers(q);

    #Generate random matrix A with m rows, n columns and full rank
    rank_A = 0;
    while rank_A < m:
        A = random_matrix(Zq,m,n);
        rank_A = rank(A);


    #Find kernel element with all distinct elements
    #Use A as parity-check matrix of code C, compute generator for C and find codeword with distinct entries
    #Exploit information set to speed-up the search

    k = n-m;

    C_dual = codes.LinearCode(A); #code generated by A
    G_A = C_dual.parity_check_matrix(); #generator matrix for code whose parity-check is A

    #Check if there G_A can be put into systematic form, otherwise apply random permutation
    while rank(G_A[:,0:k])< k:
        P = Permutations(range(1,n+1)).random_element().to_matrix();
        A = A*P;
        G_A = G_A*P;


    G_A_sys = G_A[:,0:k]^-1*G_A;

    flag_c = 0; #flag_c = 1 when codeword with distinct entries is found
    while flag_c == 0:

        #Generate u with k distinct entries
        P = Permutations(range(n)).random_element();
        U = random_matrix(Zq,ell,k);

        #Compute codeword corresponding to u
        C = U*G_A_sys;

        #Check if u has all distinct entries
        unique_values = uniq([str(C[:, i]) for i in range(n)]);
        if len(unique_values) == n:
            flag_c = 1;

    ##Apply random permutations
    secret_P = Permutations(range(n)).random_element();
    C_perm = matrix(Zq,ell,n);
    for i in range(n):
        C_perm[:, i] = C[:,secret_P[i]];


    return A, C, C_perm, secret_P;


#################################################


#Obtain theoretical estimates for relevant attack parameters

def estimate_theoretical_values(n,m,q,ell,w,w1,w2,d,u):

    r = m+1;

    #Sizes of lists K1 and K2
    th_list_sizes_first_level = [log2( factorial(n)/factorial(n-w1)), log2(factorial(n)/factorial(n-w2) )];

    #Number of collisions between K1 and K2
#    th_num_collisions_first_level = max(0,th_list_sizes_first_level[0]+th_list_sizes_first_level[1]-ell*d*log2(q));
    th_num_collisions_first_level = log2( max(1,factorial(n)^2*q^(-d*ell)/factorial(n-w1)/factorial(n-w2)  ) );

    #Size of list K
    th_size_K = max(1, factorial(n)/factorial(n-w)*q^(-d*ell) );

    #Sizes of lists L1 and L2
    th_list_sizes_second_level = [log2( factorial(n)/factorial(r+w-u)), log2(th_size_K)];

    #Number of collisions between L1 and L2
    th_num_collisions_second_level = max(0,log2( factorial(n)/(factorial(r+w-u))*th_size_K*q^(-ell*(u-d)) ) );

    #Size of final list L
    th_size_L = factorial(n-w)/(factorial(r-u))*q^(-ell*(u-d))*th_size_K;

    return th_list_sizes_first_level, th_num_collisions_first_level, log2(th_size_K), th_list_sizes_second_level, th_num_collisions_second_level, log2(th_size_L);


###################################################
##Parameters for the PKP instance
n = 17; #code length
m = 10; #number of kernel equations
q = 5; #finite field size
ell = 3; #dimension of input PKP instance

#Parameters for the attack (for their meaning, check the paper)
w = 6;
w1 = 4;
w2 = 2;
d = 2;
u = 4;

#Number of subcodes with support size w and dimension d; if this value is <1, it is likely that
#the chosen parameters are not OK (i.e., a subcode with the desired properties does not exist)
Nw =   N_w = binomial(n,w)*(q^d-1)^(w-d)*gauss_binomial(m+1,d,q)/gauss_binomial(n,d,q);

print("Number of "+str(d)+"-dimensional subcodes with supp size "+str(w)+" is "+str(Nw*1.));


#Sanity-check on the parameters; if the expected number of solutions is higher than 1, raise a warning
num_perm = factorial(n);
pr_kernel = q^(-m*ell);
if num_perm*pr_kernel>1:
    print("Wait, you may have more than one solution...");


#Obtain theoretical estimates
th_list_sizes_first_level, th_num_collisions_first_level, th_size_K, th_list_sizes_second_level, th_num_collisions_second_level, th_size_L = estimate_theoretical_values(n,m,q,ell,w,w1,w2,d,u);


##Generate random PKP instance: C is the actual subcode, while challenge_C is the subcode which is input of the PKP instance. In other words, PKP is solved when a permutation pi such that challenge_C = pi(C) is found
Zq = Integers(q); #ring of integers mod q

if ell == 1:
    A, C, challenge_C, secret_P = random_PKP_instance_mono_dimensional(q, n, m);  #random instance; c is the un-permuted vector, challenge_c is the permuted one; secret_P is the secret permutation
else:
    A, C, challenge_C, secret_P = random_PKP_instance_multi_dimensional(q, n, m, ell);  #random instance; c is the un-permuted vector, challenge_c is the permuted one; secret_P is the secret permutation


#Enrich A with the row formed by all ones and compute s
r = m+1; 
H = block_matrix(Zq,2,1,[A,ones_matrix(Zq,1,n)]);

E = matrix(Zq,ell,r);
for i in range(n):
    E[:,r-1] += challenge_C[:,i];
    

#Call ISD to find codeword with weight w
print("Calling ISD to find subcode with support size "+str(w)+"...");
ok2 = 0;
num_attempts = 0;
while ok2 == 0:
    num_attempts+=1;
#    print("num ISD calls = "+str(num_attempts));
    ok1, ok2, sub_H = subcodes_lee_brickell_isd(Zq,H,n,r,w,d);
print("Subcode found, starting with lists...");

#Apply first transformation (permutation and change of basis) on H and s 
first_pos = matrix_support(sub_H,d,n);
rem_pos = Set(range(n)).difference(Set(first_pos)).list();
perm = rem_pos[0:n-r+u-w]+first_pos+rem_pos[n-r+u-w:n-w];

H_perm = matrix(Zq,r,n);
for i in range(n):
    H_perm[:,i] = H[:,perm[i]];
    
sub_H_perm = matrix(Zq,d,n);
for i in range(n):
    sub_H_perm[:,i] = sub_H[:,perm[i]];

C_perm = matrix(Zq,ell,n);
for i in range(n):
    C_perm[:,i] = C[:,perm[i]];
    
S = matrix(sub_H_perm)[:,0:r]*H_perm[:,0:r]^-1;
    
hat_E = E*S.transpose();

#Start preparing lists K1 and K2; every list is represented by a pair of values and corresponding sub-syndromes through H1tr and H2tr
#sub_H_perm_for_lists = matrix(sub_H_perm)[:,first_pos];
sub_H1tr = sub_H_perm[:, n-r+u-w:n-r+u-w+w1].transpose();
sub_H2tr = sub_H_perm[:, n-r+u-w+w1:n-r+u].transpose();

print("---> Preparing initial lists K1 and K2...");
list_values_1, list_sums_1 = prepare_lists(Zq, challenge_C, w1, sub_H1tr, matrix(Zq,ell,d), 1);
list_values_2, list_sums_2 = prepare_lists(Zq, challenge_C, w2, sub_H2tr, hat_E, -1);


#Find collisions 
indexes_collisions = colliding_indexes(list_sums_1,list_sums_2); #indexes of collisions for lists 1 and 2


##Check sizes of the obtained lists, and number of collisions (compare with theoretical values)
emp_list_sizes = [log2(len(list_values_1)), log2(len(list_values_2))];

print("Level 1 statistics");
print("-------- Emp initial sizes (in log2) = "+str(emp_list_sizes));
print("--------: Th theoretical sizes  (in log2) = "+str(th_list_sizes_first_level));

print("--------: Emp num_collisions (in log2) = "+str(log2(len(indexes_collisions))));
print("--------: Th num collisions (in log2) = "+str(th_num_collisions_first_level) );

#Merge the lists to remove badly constructed elements
list_values_1 = merge_lists(Zq, list_values_1, list_values_2, indexes_collisions, w1+w2, ell);

print("--------: Emp size of produced list (in log2) = "+str(log2(len(list_values_1))));

print("--------: Th size of produced list  (in log2) = "+str(th_size_K) );


#Put H_perm in systematic form, apply same transformation to E
M = H_perm[:,n-r:n]^-1;
new_H_perm = M*H_perm;
check_H = new_H_perm[d:r,:];
check_E = E*M.transpose();

check_E = check_E[:,d:r];

#Prepare lists L1 and L2
sub_H1tr = check_H[0:u-d, 0:n-r+u-w].transpose();
sub_H2tr = check_H[0:u-d, n-r+u-w:n-r+u].transpose();

print("---> Preparing lists L1 and L2...");

target_E = check_E[:, 0:u-d];

#Use the already found values to prepare the second list
list_values_2 = copy(list_values_1);
list_sums_2 = [];
for X in list_values_2:
    list_sums_2.append(target_E - X*sub_H2tr);

list_values_1, list_sums_1 = prepare_lists(Zq, challenge_C, n-r+u-w, sub_H1tr, matrix(Zq,ell,u-d), 1);


#Find collisions and then merge
indexes_collisions = colliding_indexes(list_sums_1,list_sums_2); #indexes of collisions for lists 1 and 2


##Check sizes of the obtained lists, and number of collisions (compare with theoretical values)
emp_list_sizes = [log2(len(list_values_1)), log2(len(list_values_2))];

print("Level 2 statistics");
print("--------: Emp sizes (in log2) = "+str(emp_list_sizes));
print("--------: Th theoretical sizes  (in log2) = "+str(th_list_sizes_second_level));

print("--------: Emp num_collisions (in log2) = "+str(log2(len(indexes_collisions))));
print("--------: Th num collisions (in log2) = "+str(th_num_collisions_second_level));


list_values = merge_lists(Zq, list_values_1, list_values_2, indexes_collisions, n-r+u, ell);

print("--------: Emp size of produced list (in log2) = "+str(log2(len(list_values))));
print("--------: Th size of produced list  (in log2) = "+str(th_size_L) );

#Check validity of the found candidates
print("---> Checking final candidates...");

check_Utr = check_H[u-d:r, 0:n-r].transpose();
check_E = E*M.transpose();
target_E = check_E[:,u:r];

C_list = [];
for i in range(n):
    val = 0;
    for j in range(ell):
        val += ( (ZZ(challenge_C[j,i]))*q^(j) );

    C_list.append(val);

C_set = Set(C_list);

##########################################


for X in list_values:

    Xp = target_E - X[:,0:n-r]*check_Utr;

    candidate = block_matrix(1,2,[X, Xp]);

    candidate_list = [];
    for i in range(n):
        val = 0;
        for j in range(ell):
            val += ( (ZZ(candidate[j, i]))*q^(j) );
        candidate_list.append(val);

    candidate_set = Set(candidate_list);

    common_columns_set = C_set.intersection(candidate_set);

    if common_columns_set.cardinality()==n:
        print("We found a solution!!!");
